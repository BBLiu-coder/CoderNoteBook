# 数据库

## 目录

* [存储引擎](#存储引擎)
* [事务](#事务)
* [索引](#索引)
* [写高效的SQL语句](#写高效的SQL语句)

---

## 存储引擎

* MYISAM / INNODB 的区别

    1. MYSQL(5.1的版本之后)的默认存储引擎 INNODB

    2. innodb 支持粒度更小的锁，也就是行锁

    3. innodb 支持事务

    4. 我的一个个人看法，innodb 设计的比较晚，相对于比较周全，如果没有什么特殊癖好，用innodb更好。这好像也是官方给出的建议。

* 聚簇索引和非聚簇索引

    MyISAM 是非聚簇索引，innodb是聚簇索引。 聚簇索引和非聚簇索引的一个根本的区别是，索引和真正的数据是否是存放在一起的。如果是在一起，就是聚簇索引，如果不在一起，就是非聚簇索引。

    如下图所示：
    ![tu](../pic/数据库_1.jpg)


## 事务

* 事务的特性

    ACID

    ACID 是什么意思？

    ![tu](../pic/数据库_2ACID.png)

    其中，一致性表示的是 事务只有起始状态和结束状态可以被其他事务看见，比如说，事务是 给 A -100元，给B + 100 元。那么，不一致的情况就是只给A 减去了100元，没有给B 加上100元。

* 其中，I 表示的是隔离等级

    四个隔离等级是：
    1. 读未提交

        事务可以读到其他事务修改过（但是未提交的数据）
    2. 读提交

        事务可以只能读到其他事务提交过后的事务

    3. 可重复读

        在一个事务中，多次读取一个变量，它的数值是一样的。

        （事务A在开始的时候，查询了一次变量a=100。然后，事务b启动，修改了一次变量a=200，然后提交。然后，事务A还没有结束，然后，继续查询了一次变量a。这个变量是多少呢？  如果隔离等级是读提交，这个a是=200；如果隔离等级是可重复读，这个a=100。因为一个事务中，读到的变量是一样的。）

    4. 串行化

        读的变量加读锁，写的变量加写锁。读写锁冲突的时候，避免并行访问。

    举个例子：
    ![tu](../pic/数据库_3隔离等级.png)

    * 如果事务的隔离等级是 ：读未提交
    那么，事务B将变量的值从1修改为2，事务A在v1的值=2。（事务A读到事务B修改但是未提交的东西。）

    * 如果事务的隔离等级是：读提交
    那么，事务B将变量的值从1修改为2，事务A在v1的值=1，V2=2。（事务A读到事务B修改但是未提交的东西。）

    * 如果事务的隔离等级是: 可重复读
    那么，事务A读到的v1=1，然后，事务b把1修改为2，然后提交。事务a在查询的时候，为了保证可重复读，那么一定要等于v2=1。（保证一个事务中读到的变量是一样的）

    * 如果事务的隔离等级是：串行化
    那么事务a查询的时候，加上读锁。事务b修改的时候，试图加写锁。然后被block。等待事务a结束，释放读锁，然后事务b继续执行。

    隔离等级试图解决下面的几个问题：

    1. 脏读

        （读未提交的情况下，会出现脏读）

        脏读指的是：一个事务插入一条数据，然后再rollback。另外一个是事务分别再插入数据之后和rollback之后查询两次，读到的数据是不一样的。
    
    2. 不可重复读

        （读提交的情况下，会出现不可重复读）

        一个事务插入一条数据，然后再commit。另外一个事务分别在commit之前读和commit之后读，得到的结果是不一样的。


    3. 幻读 

        （可重复读的情况下，会出现幻读的情况）
        
        在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。

* 常用数据库的隔离级别：

    Orcale的隔离等级是**读提交**

    MySQL的隔离级别是**可重复读（第三级别的等级）** mysql的级别要更高一点哎 ~


* 参考：

    [廖雪峰-事务](https://www.liaoxuefeng.com/wiki/001508284671805d39d23243d884b8b99f440bfae87b0f4000/0015091672511496641de7eeea04f67bf55ccf22e35e428000)


### redis 是如何保证ACID

1. 原子性 

    redis multi 开始事务，然后开始把后面的命令加入事务队列。
    然后，等待事务commit，然后把这个事务里面的所有命令一次。

    所以，原子性是什么，事务的队列里面的命令要不执行，要不然就都执行。
    （如果队列里面命令 有些是错误的，那么后面的命令依然会执行。**一旦所有的命令被加入队列成功，事务就被执行，如果其中有的命令被执行错误，后面的命令依然会被执行，redis不会像mysql一样回滚。**）

    **这个要注意一点，如果命令加入执行队列就错误的话，这个命令不会exec的时候，就会返回错误。（都不执行）**

    所以，redis是有一致性的。事务的命令要不不执行，要不然都执行。

2. 一致性

    事务只会有两个结果，要不执行成功，要不没有执行。不会有中间状态。

    《redis的设计与实现》书中概括了三点：

    1. 事务命令加入队列错误：

        事务加入队列错误的时候，exec就会错误。事务不会执行。然后还是一致的。

    2. 事务命令执行错误

        事务的命令执行错误，事务依然会执行，错误的命令不会影响一致性。

    3. redis 挂机

        * 没有rdb备份的时候断电：

            那重启之后，redis是空。

        * rdb备份的时候：

            重启之后，是rdb的镜像。

        * aof备份：

            是aof恢复后的状态。

3. 隔离性

    **隔离性的核心是 牺牲一部分一致性，来获得事务的并行和性能。**
    redis直接把事务串行化，事务不可以并行，不可以被中断，而且redis本身就是单线程的。

    所以，redis没有mysql隔离等级一说，或者是它的隔离等级是串行化。

4. 持久性

    如果开始了aof，并且是最高级别的aof，每一条命令都会被立刻同步到磁盘，那么redis是可以保证持久性的。

## 索引

- [数据库索引](./数据库-索引.md)

## 写高效的SQL语句

* explain


## SQL的教程

- [SQL教程](https://www.liaoxuefeng.com/wiki/001508284671805d39d23243d884b8b99f440bfae87b0f4000)

* 看完廖雪峰的教程可以思考几个问题：

    * 数据库的主键应该如何设置？什么样的列适合做主键？

        **主键有两个特征，第一就是不可以重复，第二是不可以修改。**

        **一般不适用业务逻辑的字段设置为主键，主键一般会新设置一列，它的属性是自增。**

        因为，业务逻辑可能会更改，如果用身份证的id做主键，比如有一天身份证的位数不够了，需要修改，这样就比较麻烦了。

    * 外键是什么？需要设置外键吗？加入外键的优点和缺点

        **外键是数据库的一种约束**，但是这样往往可能会造成效率上面的问题。另外一种方式就是由上层的业务层这样约束的可靠性，而数据库不设置外键。

    * 加入索引的优点和缺点

        1. 加入索引可以提交查询的效率，但是插入数据和删除数据时，同样需要修改索引。同时，设置索引还会有空间的开销。

        2. 索引要有区分度。男女性别这样的就不适合做索引

    * 索引和主键的区别

        1. 由于主键的设置在没有意义的字段上面，这个时候就可以给经常查询的业务字段上面设置唯一索引。来提高查询效率。

