# unix 环境高级编程

## 目录
* [文件IO](文件IO)
* [文件和目录](文件和目录)
* [IO标准库](IO标准库)
* [进程环境](进程环境)
* [进程控制](进程控制)


---
## 文件IO

linux对于文件io提供的系统调用大概是5个，分别是 open，read，write，lseek，close 。

* 关于write 

    * write 函数的流程

        **调用write函数的将数据写入磁盘的过程**

        进入内核空间 --> 将数据写入内核空间里面的缓冲区 --> 写队列 --> 磁盘

        一般默认的write函数，只负责将数据写到内核空间的缓冲区里面，然后返回，它并不等待写磁盘的操作结束。 系统的守护进程会周期的调用sync函数，将内核空间的write缓冲区的数据放到写队列。fsync函数可以确保修改过的数据，直到写到磁盘上面再返回。

    * write 函数的追加写

        write函数的追加写的实现是一个原子操作，因为如果两个进程同时打开一个文件，近些追加写的时候。如果获得 文件偏移 和 写操作 这个两个操作是独立的话，那么就可以出现被覆盖的情况。所以，write的追加写的操作是一个原子的操作。

* 关于read


* 其他的api

    ```
    dup/dup2  #复制fd
    fcntl     #改变打开文件的属性
    ioctl     #
    ```

* 进程打开文件对应的数据结构

    进程打开文件对应的数据结构,如下图所示：
    ![](../pic/c_and_c++_1.jpg)

## 文件和目录

* linux 的文件类型
    
    * 普通文件

    * 目录文件

    * 块特殊文件 
    
        磁盘文件就是块特殊文件。

    * 字符特殊文件

        在系统中，所有设备，要不是字符特殊文件，要不就是块特殊文件。比如终端输入就是字符特殊文件。

    * FIFO 

    * SOCKET

    * 符号链接

* 目录

    每一个进程都一个自己当前的工作目录，这个目录也是搜索所有相对路径名的起点。
    **附加一个问题，自己可以去实现cd命令。**

* linux 文件系统

    todo


## IO标准库

* 缓冲
    
    标准io库提供缓冲的目的是为了尽可能的减少调用read 和 write 的次数。于是，标准io库提供了缓冲的机制。标准io库的缓冲机制分为三种：

    * 全缓冲

        全缓冲表示直到写满缓冲区的时候，才进行实际的io操作。

    * 行缓冲

        行缓冲表示遇到/n就进行fflush的操作，或者是达到了行缓冲的大小，就执行fflush（好像默认是1024）。这个是stdin 和 stdout的默认操作行缓冲。

    * 不带缓冲

        不缓冲就是不缓冲。stderr就是不缓冲。
    
    （这个说的stdin，stdout 是行缓冲 指的是他们默认连接至终端）

* 关于 stdin , stdout , stderr

    stdin，stdout，stderr默认是连接至终端，也就是从终端获取输入和输出。但是也可以通过重定向修改默认的路径。

    ```
    ./a.out < /etc/passwd  > std.out 2>std.err

    # 这个表示 
    # stdin 是从 /etc/passwd 获得输入
    # stdout 输出道std.out 文件里面
    # stderr 输出道std.err 文件里面
    ```

    如果stdin，stdout被重定向到文件，那么它们就变成全缓冲了。


## 进程环境

    * 程序启动

    * 进程终止

## 进程控制

* 理解fork

    * 父进程打开三个文件，然后fork出子进程，然后两个进程一个写文件，会发生什么？
    
        fork之后，父进程和子进程是共享同一个文件偏移量的。如果子进程写了文件之后，写完之后，会修改文件的偏移。于是，父进程再写的时候，就会在新的偏移后面写。（但是这个只能保证不会出现父子进程写的内容相互覆盖，并不能保证内容的顺序）

        比如，子进程写的是abc，父进程写的是123。可能出现的输出是a123bc，或是是1ab23c 等。但是不会出现覆盖的情况，输出的长度一定是6。

    * fork 和 vfork的区别？

        区别：

        * 没有完全拷贝父进程的进程空间里面的全部内容
        * 子进程先执行